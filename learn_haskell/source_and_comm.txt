----||----
Source:

https://www.haskell.org/
http://learnyouahaskell.com/


----||----
About Haskell:

Purely functional programming language.
Scripts format is myfunction.hs.
"bar (bar 3)" would be in imperative language (C) something like this "bar(bar(3))."
Everytime we change something in script, we have to (re)load it (with compiler in terminal).
Functions cannot have variable with capitalized letter and also they can contain '.
Haskell has type inference. (will figure out if something is number without specifying it; though there is type decleration)


Data Structures:
---
Integers and Float (& Double) numbers:
    Don't have to predefine them.
    Basic arithmetics works fine together.
    Negative numbers have to be in parenthesis.
    Usually on 32-bit machines the maximum possible Int is 2147483647 and the minimum is -2147483648.



Functions:
Functions are called by typing their name then one space then inputs (can repeat for inputs), except
an infix function, which is called for example like this '92 `div` 10'.
Functions that have type variables are called polymorphic functions.



String:
Defined by " ".
"++" or ":" same like with list.
Same indexing like with list.



List:
In Haskell, lists are a homogenous data structure.
"++" put two list together. Slow for long list, but ":" (cons operator) is instantaneous, but first input is not list.
[1,2,3] is actually just syntactic sugar for 1:2:3:[]. ([] is empty list)
To show element from list use '!! index' (start from 0).
When using <, <=, > and >= (and ==) to compare lists, they are compared in lexicographical order
(head, tail, last, init) functions performed on empty list return Errir,
    Be careful with it 'cause it's can't be catch during compile time.
List ranges (Texas Range); use defined difference between numbers and range is defined by number behind ".." for example:
        [1..20] will yield [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
        [20,18..0] will yield [20,18,16,14,12,10,8,6,4,2,0]
        [int..] will yield infinite list
    The float numbers have funky results.
    [1,2,4,8,16..100] won't work 'cause:
        Firstly because you can only specify one step. And secondly because some sequences that aren't arithmetic are ambiguous
             if given only by a few of their first terms.



Tuple:
Similiar to list, but not homogenous.
Can contain several types of data structures.
Cannot be infinitive.
Tuples in list needs to be homogenous.
Use tuples when you know in advance how many components some piece of data should have. 
    Tuples are much more rigid because each different size of tuple is its own type, 
        so you can't write a general function to append an element to a tuple â€” 
        you'd have to write a function for appending to a pair, 
        one function for appending to a triple, 
        one function for appending to a 4-tuple, etc.



---
List of predefined functions :
Dict:
    num = int or float or Double
    var = int or float or string or list or tuple
    *This doesn't mean it works always (exception like lenghts etc...)
succ num            -> return num+1
min num num         -> return the lowest number
max num num         -> return the biggest number
let var             -> in ghci it define variable
head list           -> return first element of list
tail list           -> return list with every element except first one
last list           -> return last element of list
init list           -> return list with every element except last one
lenght list         -> return lenght of list (number of elements its contain)
null list           -> return True/False if list is empty
reverse list        -> return flip order of elements in list
take int list       -> return list with elements from beggining to input int
drop int list       -> return list with elements from input int to end
maximum list        -> return biggest element
minimum list        -> return smallest element
sum list            -> return sum of all elements
product list        -> return product of all elements
elem int list       -> return True/False if int is in list
cycle list          -> return infinite list that is cycling
repeat num          -> return infinite list full of input
take function       -> return limited range for functions like cycle etc...
replicate int num   -> return list of num with int range
fst var             -> return first element of pair
snd var             -> return second element of pair
zip var var         -> return joint list of tuples from both vars (works even with inf var with fin var)


----||----
List comprehension:
[set | range(s) / input(s), condition(s)]

Examples:
    [x*2 | x <- [1..10]]
    [ x | x <- [50..100], x `mod` 7 == 3]
    boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
    [ x | x <- [10..20], x /= 13, x /= 15, x /= 19]
    [ x*y | x <- [2,5,10], y <- [8,10,11]]
    length' xs = sum [1 | _ <- xs]
    removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
    [ [ x | x <- xs, even x ] | xs <- xxs]
    let rightTriangles' = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24] 

    type decleration:
    removeNonUppercase :: [Char] -> [Char]  
    removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
    >>>
    addThree :: Int -> Int -> Int -> Int  
    addThree x y z = x + y + z  


Notes:
- weeding out lists by predicates is also called filtering. We took a list of numbers and we filtered them by the predicate.
- '_' means we don't care about variable so it won't have a name


----||----
Commands:

ghci -> set interactive compiler in terminal

:l myfunction -> load script (everytime when we do change in scripts)

:r -> reload the script

:quit -> quit ghci

:set prompt "ghci> " -> change prompt to 'ghci> ' from 'Prelude> '

:t -> show data type of variable